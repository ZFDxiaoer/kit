// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cmd.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cmd_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_cmd_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_cmd_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cmd_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_cmd_2eproto;
namespace pb {
class ChangeNicknameReq;
struct ChangeNicknameReqDefaultTypeInternal;
extern ChangeNicknameReqDefaultTypeInternal _ChangeNicknameReq_default_instance_;
class ChangeNicknameRsp;
struct ChangeNicknameRspDefaultTypeInternal;
extern ChangeNicknameRspDefaultTypeInternal _ChangeNicknameRsp_default_instance_;
class ChatMsg;
struct ChatMsgDefaultTypeInternal;
extern ChatMsgDefaultTypeInternal _ChatMsg_default_instance_;
class CmdData;
struct CmdDataDefaultTypeInternal;
extern CmdDataDefaultTypeInternal _CmdData_default_instance_;
class EchoCmd;
struct EchoCmdDefaultTypeInternal;
extern EchoCmdDefaultTypeInternal _EchoCmd_default_instance_;
class EnterRoomReq;
struct EnterRoomReqDefaultTypeInternal;
extern EnterRoomReqDefaultTypeInternal _EnterRoomReq_default_instance_;
class EnterRoomRsp;
struct EnterRoomRspDefaultTypeInternal;
extern EnterRoomRspDefaultTypeInternal _EnterRoomRsp_default_instance_;
class LeaveRoomReq;
struct LeaveRoomReqDefaultTypeInternal;
extern LeaveRoomReqDefaultTypeInternal _LeaveRoomReq_default_instance_;
class LeaveRoomRsp;
struct LeaveRoomRspDefaultTypeInternal;
extern LeaveRoomRspDefaultTypeInternal _LeaveRoomRsp_default_instance_;
class LoginReq;
struct LoginReqDefaultTypeInternal;
extern LoginReqDefaultTypeInternal _LoginReq_default_instance_;
class LoginRsp;
struct LoginRspDefaultTypeInternal;
extern LoginRspDefaultTypeInternal _LoginRsp_default_instance_;
class MsgNotify;
struct MsgNotifyDefaultTypeInternal;
extern MsgNotifyDefaultTypeInternal _MsgNotify_default_instance_;
class NicknameChangeNotify;
struct NicknameChangeNotifyDefaultTypeInternal;
extern NicknameChangeNotifyDefaultTypeInternal _NicknameChangeNotify_default_instance_;
class PingNotify;
struct PingNotifyDefaultTypeInternal;
extern PingNotifyDefaultTypeInternal _PingNotify_default_instance_;
class RegisterReq;
struct RegisterReqDefaultTypeInternal;
extern RegisterReqDefaultTypeInternal _RegisterReq_default_instance_;
class RegisterRsp;
struct RegisterRspDefaultTypeInternal;
extern RegisterRspDefaultTypeInternal _RegisterRsp_default_instance_;
class SendMsgReq;
struct SendMsgReqDefaultTypeInternal;
extern SendMsgReqDefaultTypeInternal _SendMsgReq_default_instance_;
class SendMsgRsp;
struct SendMsgRspDefaultTypeInternal;
extern SendMsgRspDefaultTypeInternal _SendMsgRsp_default_instance_;
class UserEnterNotify;
struct UserEnterNotifyDefaultTypeInternal;
extern UserEnterNotifyDefaultTypeInternal _UserEnterNotify_default_instance_;
class UserLeaveNotify;
struct UserLeaveNotifyDefaultTypeInternal;
extern UserLeaveNotifyDefaultTypeInternal _UserLeaveNotify_default_instance_;
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> ::pb::ChangeNicknameReq* Arena::CreateMaybeMessage<::pb::ChangeNicknameReq>(Arena*);
template<> ::pb::ChangeNicknameRsp* Arena::CreateMaybeMessage<::pb::ChangeNicknameRsp>(Arena*);
template<> ::pb::ChatMsg* Arena::CreateMaybeMessage<::pb::ChatMsg>(Arena*);
template<> ::pb::CmdData* Arena::CreateMaybeMessage<::pb::CmdData>(Arena*);
template<> ::pb::EchoCmd* Arena::CreateMaybeMessage<::pb::EchoCmd>(Arena*);
template<> ::pb::EnterRoomReq* Arena::CreateMaybeMessage<::pb::EnterRoomReq>(Arena*);
template<> ::pb::EnterRoomRsp* Arena::CreateMaybeMessage<::pb::EnterRoomRsp>(Arena*);
template<> ::pb::LeaveRoomReq* Arena::CreateMaybeMessage<::pb::LeaveRoomReq>(Arena*);
template<> ::pb::LeaveRoomRsp* Arena::CreateMaybeMessage<::pb::LeaveRoomRsp>(Arena*);
template<> ::pb::LoginReq* Arena::CreateMaybeMessage<::pb::LoginReq>(Arena*);
template<> ::pb::LoginRsp* Arena::CreateMaybeMessage<::pb::LoginRsp>(Arena*);
template<> ::pb::MsgNotify* Arena::CreateMaybeMessage<::pb::MsgNotify>(Arena*);
template<> ::pb::NicknameChangeNotify* Arena::CreateMaybeMessage<::pb::NicknameChangeNotify>(Arena*);
template<> ::pb::PingNotify* Arena::CreateMaybeMessage<::pb::PingNotify>(Arena*);
template<> ::pb::RegisterReq* Arena::CreateMaybeMessage<::pb::RegisterReq>(Arena*);
template<> ::pb::RegisterRsp* Arena::CreateMaybeMessage<::pb::RegisterRsp>(Arena*);
template<> ::pb::SendMsgReq* Arena::CreateMaybeMessage<::pb::SendMsgReq>(Arena*);
template<> ::pb::SendMsgRsp* Arena::CreateMaybeMessage<::pb::SendMsgRsp>(Arena*);
template<> ::pb::UserEnterNotify* Arena::CreateMaybeMessage<::pb::UserEnterNotify>(Arena*);
template<> ::pb::UserLeaveNotify* Arena::CreateMaybeMessage<::pb::UserLeaveNotify>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pb {

enum RegisterRsp_Retcode : int {
  RegisterRsp_Retcode_RET_SUCC = 0,
  RegisterRsp_Retcode_RET_FAIL = 1,
  RegisterRsp_Retcode_RET_USERNAME_LEN_ERROR = 2,
  RegisterRsp_Retcode_RET_USERNAME_REPEAT = 3,
  RegisterRsp_Retcode_RET_NICKNAME_LEN_ERROR = 4,
  RegisterRsp_Retcode_RET_PASSWD_TOO_SHORT = 5,
  RegisterRsp_Retcode_RET_REGISTER_TOO_OFFEN = 6,
  RegisterRsp_Retcode_RegisterRsp_Retcode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RegisterRsp_Retcode_RegisterRsp_Retcode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RegisterRsp_Retcode_IsValid(int value);
constexpr RegisterRsp_Retcode RegisterRsp_Retcode_Retcode_MIN = RegisterRsp_Retcode_RET_SUCC;
constexpr RegisterRsp_Retcode RegisterRsp_Retcode_Retcode_MAX = RegisterRsp_Retcode_RET_REGISTER_TOO_OFFEN;
constexpr int RegisterRsp_Retcode_Retcode_ARRAYSIZE = RegisterRsp_Retcode_Retcode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegisterRsp_Retcode_descriptor();
template<typename T>
inline const std::string& RegisterRsp_Retcode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegisterRsp_Retcode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegisterRsp_Retcode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegisterRsp_Retcode_descriptor(), enum_t_value);
}
inline bool RegisterRsp_Retcode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RegisterRsp_Retcode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegisterRsp_Retcode>(
    RegisterRsp_Retcode_descriptor(), name, value);
}
enum LoginRsp_Retcode : int {
  LoginRsp_Retcode_RET_SUCC = 0,
  LoginRsp_Retcode_RET_FAIL = 1,
  LoginRsp_Retcode_RET_ACCOUNT_ERROR = 2,
  LoginRsp_Retcode_RET_ACCOUNT_FREEZE = 3,
  LoginRsp_Retcode_RET_ACCOUNT_ONLINE = 4,
  LoginRsp_Retcode_LoginRsp_Retcode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LoginRsp_Retcode_LoginRsp_Retcode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LoginRsp_Retcode_IsValid(int value);
constexpr LoginRsp_Retcode LoginRsp_Retcode_Retcode_MIN = LoginRsp_Retcode_RET_SUCC;
constexpr LoginRsp_Retcode LoginRsp_Retcode_Retcode_MAX = LoginRsp_Retcode_RET_ACCOUNT_ONLINE;
constexpr int LoginRsp_Retcode_Retcode_ARRAYSIZE = LoginRsp_Retcode_Retcode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoginRsp_Retcode_descriptor();
template<typename T>
inline const std::string& LoginRsp_Retcode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginRsp_Retcode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginRsp_Retcode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoginRsp_Retcode_descriptor(), enum_t_value);
}
inline bool LoginRsp_Retcode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginRsp_Retcode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoginRsp_Retcode>(
    LoginRsp_Retcode_descriptor(), name, value);
}
enum EnterRoomRsp_Retcode : int {
  EnterRoomRsp_Retcode_RET_SUCC = 0,
  EnterRoomRsp_Retcode_RET_FAIL = 1,
  EnterRoomRsp_Retcode_RET_ROOM_FULL = 2,
  EnterRoomRsp_Retcode_EnterRoomRsp_Retcode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EnterRoomRsp_Retcode_EnterRoomRsp_Retcode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EnterRoomRsp_Retcode_IsValid(int value);
constexpr EnterRoomRsp_Retcode EnterRoomRsp_Retcode_Retcode_MIN = EnterRoomRsp_Retcode_RET_SUCC;
constexpr EnterRoomRsp_Retcode EnterRoomRsp_Retcode_Retcode_MAX = EnterRoomRsp_Retcode_RET_ROOM_FULL;
constexpr int EnterRoomRsp_Retcode_Retcode_ARRAYSIZE = EnterRoomRsp_Retcode_Retcode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EnterRoomRsp_Retcode_descriptor();
template<typename T>
inline const std::string& EnterRoomRsp_Retcode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EnterRoomRsp_Retcode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EnterRoomRsp_Retcode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EnterRoomRsp_Retcode_descriptor(), enum_t_value);
}
inline bool EnterRoomRsp_Retcode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EnterRoomRsp_Retcode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EnterRoomRsp_Retcode>(
    EnterRoomRsp_Retcode_descriptor(), name, value);
}
enum LeaveRoomRsp_Retcode : int {
  LeaveRoomRsp_Retcode_RET_SUCC = 0,
  LeaveRoomRsp_Retcode_RET_FAIL = 1,
  LeaveRoomRsp_Retcode_LeaveRoomRsp_Retcode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LeaveRoomRsp_Retcode_LeaveRoomRsp_Retcode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LeaveRoomRsp_Retcode_IsValid(int value);
constexpr LeaveRoomRsp_Retcode LeaveRoomRsp_Retcode_Retcode_MIN = LeaveRoomRsp_Retcode_RET_SUCC;
constexpr LeaveRoomRsp_Retcode LeaveRoomRsp_Retcode_Retcode_MAX = LeaveRoomRsp_Retcode_RET_FAIL;
constexpr int LeaveRoomRsp_Retcode_Retcode_ARRAYSIZE = LeaveRoomRsp_Retcode_Retcode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LeaveRoomRsp_Retcode_descriptor();
template<typename T>
inline const std::string& LeaveRoomRsp_Retcode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeaveRoomRsp_Retcode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeaveRoomRsp_Retcode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LeaveRoomRsp_Retcode_descriptor(), enum_t_value);
}
inline bool LeaveRoomRsp_Retcode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeaveRoomRsp_Retcode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LeaveRoomRsp_Retcode>(
    LeaveRoomRsp_Retcode_descriptor(), name, value);
}
enum SendMsgRsp_Retcode : int {
  SendMsgRsp_Retcode_RET_SUCC = 0,
  SendMsgRsp_Retcode_RET_FAIL = 1,
  SendMsgRsp_Retcode_RET_NOT_IN_ROOM = 2,
  SendMsgRsp_Retcode_SendMsgRsp_Retcode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SendMsgRsp_Retcode_SendMsgRsp_Retcode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SendMsgRsp_Retcode_IsValid(int value);
constexpr SendMsgRsp_Retcode SendMsgRsp_Retcode_Retcode_MIN = SendMsgRsp_Retcode_RET_SUCC;
constexpr SendMsgRsp_Retcode SendMsgRsp_Retcode_Retcode_MAX = SendMsgRsp_Retcode_RET_NOT_IN_ROOM;
constexpr int SendMsgRsp_Retcode_Retcode_ARRAYSIZE = SendMsgRsp_Retcode_Retcode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SendMsgRsp_Retcode_descriptor();
template<typename T>
inline const std::string& SendMsgRsp_Retcode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SendMsgRsp_Retcode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SendMsgRsp_Retcode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SendMsgRsp_Retcode_descriptor(), enum_t_value);
}
inline bool SendMsgRsp_Retcode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SendMsgRsp_Retcode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SendMsgRsp_Retcode>(
    SendMsgRsp_Retcode_descriptor(), name, value);
}
enum ChangeNicknameRsp_Retcode : int {
  ChangeNicknameRsp_Retcode_RET_SUCC = 0,
  ChangeNicknameRsp_Retcode_RET_FAIL = 1,
  ChangeNicknameRsp_Retcode_RET_NICKNAME_LEN_ERROR = 2,
  ChangeNicknameRsp_Retcode_ChangeNicknameRsp_Retcode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChangeNicknameRsp_Retcode_ChangeNicknameRsp_Retcode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChangeNicknameRsp_Retcode_IsValid(int value);
constexpr ChangeNicknameRsp_Retcode ChangeNicknameRsp_Retcode_Retcode_MIN = ChangeNicknameRsp_Retcode_RET_SUCC;
constexpr ChangeNicknameRsp_Retcode ChangeNicknameRsp_Retcode_Retcode_MAX = ChangeNicknameRsp_Retcode_RET_NICKNAME_LEN_ERROR;
constexpr int ChangeNicknameRsp_Retcode_Retcode_ARRAYSIZE = ChangeNicknameRsp_Retcode_Retcode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeNicknameRsp_Retcode_descriptor();
template<typename T>
inline const std::string& ChangeNicknameRsp_Retcode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChangeNicknameRsp_Retcode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChangeNicknameRsp_Retcode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChangeNicknameRsp_Retcode_descriptor(), enum_t_value);
}
inline bool ChangeNicknameRsp_Retcode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChangeNicknameRsp_Retcode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChangeNicknameRsp_Retcode>(
    ChangeNicknameRsp_Retcode_descriptor(), name, value);
}
enum ErrorCode : int {
  ErrorCode_NONE = 0,
  ErrorCode_System_Exception = 1,
  ErrorCode_Net_DbError = 1000,
  ErrorCode_Net_ProtocalLength = 1001,
  ErrorCode_Net_ProtocalInvalid = 1002,
  ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ErrorCode_IsValid(int value);
constexpr ErrorCode ErrorCode_MIN = ErrorCode_NONE;
constexpr ErrorCode ErrorCode_MAX = ErrorCode_Net_ProtocalInvalid;
constexpr int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorCode_descriptor();
template<typename T>
inline const std::string& ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorCode_descriptor(), enum_t_value);
}
inline bool ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorCode>(
    ErrorCode_descriptor(), name, value);
}
enum CmdId : int {
  CMD_NONE = 0,
  CMD_ECHO = 1,
  CMD_REGISTER_REQ = 101,
  CMD_REGISTER_RSP = 102,
  CMD_LOGIN_REQ = 103,
  CMD_LOGIN_RSP = 104,
  CMD_ENTER_ROOM_REQ = 105,
  CMD_ENTER_ROOM_RSP = 106,
  CMD_SEND_MSG_REQ = 107,
  CMD_SEND_MSG_RSP = 108,
  CMD_MSG_NOTIFY = 109,
  CMD_USER_ENTER_NOTIFY = 110,
  CMD_USER_LEAVE_NOTIFY = 111,
  CMD_CHANGE_NICKNAME_REQ = 112,
  CMD_CHANGE_NICKNAME_RSP = 113,
  CMD_PING_NOTIFY = 114,
  CMD_CHANGE_NICKNAME_NOTIFY = 115,
  CMD_LEAVE_ROOM_REQ = 116,
  CMD_LEAVE_ROOM_RSP = 117,
  CmdId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CmdId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CmdId_IsValid(int value);
constexpr CmdId CmdId_MIN = CMD_NONE;
constexpr CmdId CmdId_MAX = CMD_LEAVE_ROOM_RSP;
constexpr int CmdId_ARRAYSIZE = CmdId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CmdId_descriptor();
template<typename T>
inline const std::string& CmdId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CmdId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CmdId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CmdId_descriptor(), enum_t_value);
}
inline bool CmdId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CmdId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CmdId>(
    CmdId_descriptor(), name, value);
}
// ===================================================================

class CmdData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.CmdData) */ {
 public:
  inline CmdData() : CmdData(nullptr) {}
  ~CmdData() override;
  explicit constexpr CmdData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CmdData(const CmdData& from);
  CmdData(CmdData&& from) noexcept
    : CmdData() {
    *this = ::std::move(from);
  }

  inline CmdData& operator=(const CmdData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CmdData& operator=(CmdData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CmdData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CmdData* internal_default_instance() {
    return reinterpret_cast<const CmdData*>(
               &_CmdData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CmdData& a, CmdData& b) {
    a.Swap(&b);
  }
  inline void Swap(CmdData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CmdData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CmdData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CmdData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CmdData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CmdData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CmdData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.CmdData";
  }
  protected:
  explicit CmdData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmddataFieldNumber = 2,
    kCmdidFieldNumber = 1,
    kRetFieldNumber = 3,
  };
  // string cmddata = 2;
  void clear_cmddata();
  const std::string& cmddata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cmddata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cmddata();
  PROTOBUF_NODISCARD std::string* release_cmddata();
  void set_allocated_cmddata(std::string* cmddata);
  private:
  const std::string& _internal_cmddata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmddata(const std::string& value);
  std::string* _internal_mutable_cmddata();
  public:

  // uint32 cmdid = 1;
  void clear_cmdid();
  uint32_t cmdid() const;
  void set_cmdid(uint32_t value);
  private:
  uint32_t _internal_cmdid() const;
  void _internal_set_cmdid(uint32_t value);
  public:

  // uint32 ret = 3;
  void clear_ret();
  uint32_t ret() const;
  void set_ret(uint32_t value);
  private:
  uint32_t _internal_ret() const;
  void _internal_set_ret(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.CmdData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmddata_;
  uint32_t cmdid_;
  uint32_t ret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class EchoCmd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.EchoCmd) */ {
 public:
  inline EchoCmd() : EchoCmd(nullptr) {}
  ~EchoCmd() override;
  explicit constexpr EchoCmd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EchoCmd(const EchoCmd& from);
  EchoCmd(EchoCmd&& from) noexcept
    : EchoCmd() {
    *this = ::std::move(from);
  }

  inline EchoCmd& operator=(const EchoCmd& from) {
    CopyFrom(from);
    return *this;
  }
  inline EchoCmd& operator=(EchoCmd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EchoCmd& default_instance() {
    return *internal_default_instance();
  }
  static inline const EchoCmd* internal_default_instance() {
    return reinterpret_cast<const EchoCmd*>(
               &_EchoCmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EchoCmd& a, EchoCmd& b) {
    a.Swap(&b);
  }
  inline void Swap(EchoCmd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EchoCmd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EchoCmd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EchoCmd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EchoCmd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EchoCmd& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EchoCmd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.EchoCmd";
  }
  protected:
  explicit EchoCmd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:pb.EchoCmd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class ChatMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.ChatMsg) */ {
 public:
  inline ChatMsg() : ChatMsg(nullptr) {}
  ~ChatMsg() override;
  explicit constexpr ChatMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatMsg(const ChatMsg& from);
  ChatMsg(ChatMsg&& from) noexcept
    : ChatMsg() {
    *this = ::std::move(from);
  }

  inline ChatMsg& operator=(const ChatMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMsg& operator=(ChatMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMsg* internal_default_instance() {
    return reinterpret_cast<const ChatMsg*>(
               &_ChatMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ChatMsg& a, ChatMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChatMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.ChatMsg";
  }
  protected:
  explicit ChatMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kNicknameFieldNumber = 2,
    kContentFieldNumber = 4,
    kTimeFieldNumber = 3,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string nickname = 2;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // string content = 4;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // uint32 time = 3;
  void clear_time();
  uint32_t time() const;
  void set_time(uint32_t value);
  private:
  uint32_t _internal_time() const;
  void _internal_set_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.ChatMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  uint32_t time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class RegisterReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.RegisterReq) */ {
 public:
  inline RegisterReq() : RegisterReq(nullptr) {}
  ~RegisterReq() override;
  explicit constexpr RegisterReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterReq(const RegisterReq& from);
  RegisterReq(RegisterReq&& from) noexcept
    : RegisterReq() {
    *this = ::std::move(from);
  }

  inline RegisterReq& operator=(const RegisterReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterReq& operator=(RegisterReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterReq* internal_default_instance() {
    return reinterpret_cast<const RegisterReq*>(
               &_RegisterReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RegisterReq& a, RegisterReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.RegisterReq";
  }
  protected:
  explicit RegisterReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kNicknameFieldNumber = 2,
    kPasswdFieldNumber = 3,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string nickname = 2;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // string passwd = 3;
  void clear_passwd();
  const std::string& passwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* passwd);
  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(const std::string& value);
  std::string* _internal_mutable_passwd();
  public:

  // @@protoc_insertion_point(class_scope:pb.RegisterReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passwd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class RegisterRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.RegisterRsp) */ {
 public:
  inline RegisterRsp() : RegisterRsp(nullptr) {}
  ~RegisterRsp() override;
  explicit constexpr RegisterRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRsp(const RegisterRsp& from);
  RegisterRsp(RegisterRsp&& from) noexcept
    : RegisterRsp() {
    *this = ::std::move(from);
  }

  inline RegisterRsp& operator=(const RegisterRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRsp& operator=(RegisterRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRsp* internal_default_instance() {
    return reinterpret_cast<const RegisterRsp*>(
               &_RegisterRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RegisterRsp& a, RegisterRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.RegisterRsp";
  }
  protected:
  explicit RegisterRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RegisterRsp_Retcode Retcode;
  static constexpr Retcode RET_SUCC =
    RegisterRsp_Retcode_RET_SUCC;
  static constexpr Retcode RET_FAIL =
    RegisterRsp_Retcode_RET_FAIL;
  static constexpr Retcode RET_USERNAME_LEN_ERROR =
    RegisterRsp_Retcode_RET_USERNAME_LEN_ERROR;
  static constexpr Retcode RET_USERNAME_REPEAT =
    RegisterRsp_Retcode_RET_USERNAME_REPEAT;
  static constexpr Retcode RET_NICKNAME_LEN_ERROR =
    RegisterRsp_Retcode_RET_NICKNAME_LEN_ERROR;
  static constexpr Retcode RET_PASSWD_TOO_SHORT =
    RegisterRsp_Retcode_RET_PASSWD_TOO_SHORT;
  static constexpr Retcode RET_REGISTER_TOO_OFFEN =
    RegisterRsp_Retcode_RET_REGISTER_TOO_OFFEN;
  static inline bool Retcode_IsValid(int value) {
    return RegisterRsp_Retcode_IsValid(value);
  }
  static constexpr Retcode Retcode_MIN =
    RegisterRsp_Retcode_Retcode_MIN;
  static constexpr Retcode Retcode_MAX =
    RegisterRsp_Retcode_Retcode_MAX;
  static constexpr int Retcode_ARRAYSIZE =
    RegisterRsp_Retcode_Retcode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Retcode_descriptor() {
    return RegisterRsp_Retcode_descriptor();
  }
  template<typename T>
  static inline const std::string& Retcode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Retcode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Retcode_Name.");
    return RegisterRsp_Retcode_Name(enum_t_value);
  }
  static inline bool Retcode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Retcode* value) {
    return RegisterRsp_Retcode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRetcodeFieldNumber = 1,
  };
  // .pb.RegisterRsp.Retcode retcode = 1;
  void clear_retcode();
  ::pb::RegisterRsp_Retcode retcode() const;
  void set_retcode(::pb::RegisterRsp_Retcode value);
  private:
  ::pb::RegisterRsp_Retcode _internal_retcode() const;
  void _internal_set_retcode(::pb::RegisterRsp_Retcode value);
  public:

  // @@protoc_insertion_point(class_scope:pb.RegisterRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int retcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class LoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.LoginReq) */ {
 public:
  inline LoginReq() : LoginReq(nullptr) {}
  ~LoginReq() override;
  explicit constexpr LoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginReq(const LoginReq& from);
  LoginReq(LoginReq&& from) noexcept
    : LoginReq() {
    *this = ::std::move(from);
  }

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReq& operator=(LoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReq* internal_default_instance() {
    return reinterpret_cast<const LoginReq*>(
               &_LoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LoginReq& a, LoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.LoginReq";
  }
  protected:
  explicit LoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswdFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string passwd = 2;
  void clear_passwd();
  const std::string& passwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* passwd);
  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(const std::string& value);
  std::string* _internal_mutable_passwd();
  public:

  // @@protoc_insertion_point(class_scope:pb.LoginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passwd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class LoginRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.LoginRsp) */ {
 public:
  inline LoginRsp() : LoginRsp(nullptr) {}
  ~LoginRsp() override;
  explicit constexpr LoginRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRsp(const LoginRsp& from);
  LoginRsp(LoginRsp&& from) noexcept
    : LoginRsp() {
    *this = ::std::move(from);
  }

  inline LoginRsp& operator=(const LoginRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRsp& operator=(LoginRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRsp* internal_default_instance() {
    return reinterpret_cast<const LoginRsp*>(
               &_LoginRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoginRsp& a, LoginRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.LoginRsp";
  }
  protected:
  explicit LoginRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LoginRsp_Retcode Retcode;
  static constexpr Retcode RET_SUCC =
    LoginRsp_Retcode_RET_SUCC;
  static constexpr Retcode RET_FAIL =
    LoginRsp_Retcode_RET_FAIL;
  static constexpr Retcode RET_ACCOUNT_ERROR =
    LoginRsp_Retcode_RET_ACCOUNT_ERROR;
  static constexpr Retcode RET_ACCOUNT_FREEZE =
    LoginRsp_Retcode_RET_ACCOUNT_FREEZE;
  static constexpr Retcode RET_ACCOUNT_ONLINE =
    LoginRsp_Retcode_RET_ACCOUNT_ONLINE;
  static inline bool Retcode_IsValid(int value) {
    return LoginRsp_Retcode_IsValid(value);
  }
  static constexpr Retcode Retcode_MIN =
    LoginRsp_Retcode_Retcode_MIN;
  static constexpr Retcode Retcode_MAX =
    LoginRsp_Retcode_Retcode_MAX;
  static constexpr int Retcode_ARRAYSIZE =
    LoginRsp_Retcode_Retcode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Retcode_descriptor() {
    return LoginRsp_Retcode_descriptor();
  }
  template<typename T>
  static inline const std::string& Retcode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Retcode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Retcode_Name.");
    return LoginRsp_Retcode_Name(enum_t_value);
  }
  static inline bool Retcode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Retcode* value) {
    return LoginRsp_Retcode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRetcodeFieldNumber = 1,
    kUsridFieldNumber = 2,
  };
  // .pb.LoginRsp.Retcode retcode = 1;
  void clear_retcode();
  ::pb::LoginRsp_Retcode retcode() const;
  void set_retcode(::pb::LoginRsp_Retcode value);
  private:
  ::pb::LoginRsp_Retcode _internal_retcode() const;
  void _internal_set_retcode(::pb::LoginRsp_Retcode value);
  public:

  // uint32 usrid = 2;
  void clear_usrid();
  uint32_t usrid() const;
  void set_usrid(uint32_t value);
  private:
  uint32_t _internal_usrid() const;
  void _internal_set_usrid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.LoginRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int retcode_;
  uint32_t usrid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class EnterRoomReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.EnterRoomReq) */ {
 public:
  inline EnterRoomReq() : EnterRoomReq(nullptr) {}
  ~EnterRoomReq() override;
  explicit constexpr EnterRoomReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnterRoomReq(const EnterRoomReq& from);
  EnterRoomReq(EnterRoomReq&& from) noexcept
    : EnterRoomReq() {
    *this = ::std::move(from);
  }

  inline EnterRoomReq& operator=(const EnterRoomReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterRoomReq& operator=(EnterRoomReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnterRoomReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnterRoomReq* internal_default_instance() {
    return reinterpret_cast<const EnterRoomReq*>(
               &_EnterRoomReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EnterRoomReq& a, EnterRoomReq& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterRoomReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterRoomReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnterRoomReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnterRoomReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnterRoomReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnterRoomReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterRoomReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.EnterRoomReq";
  }
  protected:
  explicit EnterRoomReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
  };
  // uint32 room_id = 1;
  void clear_room_id();
  uint32_t room_id() const;
  void set_room_id(uint32_t value);
  private:
  uint32_t _internal_room_id() const;
  void _internal_set_room_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.EnterRoomReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t room_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class EnterRoomRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.EnterRoomRsp) */ {
 public:
  inline EnterRoomRsp() : EnterRoomRsp(nullptr) {}
  ~EnterRoomRsp() override;
  explicit constexpr EnterRoomRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnterRoomRsp(const EnterRoomRsp& from);
  EnterRoomRsp(EnterRoomRsp&& from) noexcept
    : EnterRoomRsp() {
    *this = ::std::move(from);
  }

  inline EnterRoomRsp& operator=(const EnterRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterRoomRsp& operator=(EnterRoomRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnterRoomRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnterRoomRsp* internal_default_instance() {
    return reinterpret_cast<const EnterRoomRsp*>(
               &_EnterRoomRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EnterRoomRsp& a, EnterRoomRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterRoomRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterRoomRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnterRoomRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnterRoomRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnterRoomRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnterRoomRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterRoomRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.EnterRoomRsp";
  }
  protected:
  explicit EnterRoomRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EnterRoomRsp_Retcode Retcode;
  static constexpr Retcode RET_SUCC =
    EnterRoomRsp_Retcode_RET_SUCC;
  static constexpr Retcode RET_FAIL =
    EnterRoomRsp_Retcode_RET_FAIL;
  static constexpr Retcode RET_ROOM_FULL =
    EnterRoomRsp_Retcode_RET_ROOM_FULL;
  static inline bool Retcode_IsValid(int value) {
    return EnterRoomRsp_Retcode_IsValid(value);
  }
  static constexpr Retcode Retcode_MIN =
    EnterRoomRsp_Retcode_Retcode_MIN;
  static constexpr Retcode Retcode_MAX =
    EnterRoomRsp_Retcode_Retcode_MAX;
  static constexpr int Retcode_ARRAYSIZE =
    EnterRoomRsp_Retcode_Retcode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Retcode_descriptor() {
    return EnterRoomRsp_Retcode_descriptor();
  }
  template<typename T>
  static inline const std::string& Retcode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Retcode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Retcode_Name.");
    return EnterRoomRsp_Retcode_Name(enum_t_value);
  }
  static inline bool Retcode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Retcode* value) {
    return EnterRoomRsp_Retcode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameListFieldNumber = 3,
    kHistoryMsgListFieldNumber = 4,
    kRetcodeFieldNumber = 1,
    kRoomIdFieldNumber = 2,
  };
  // repeated string username_list = 3;
  int username_list_size() const;
  private:
  int _internal_username_list_size() const;
  public:
  void clear_username_list();
  const std::string& username_list(int index) const;
  std::string* mutable_username_list(int index);
  void set_username_list(int index, const std::string& value);
  void set_username_list(int index, std::string&& value);
  void set_username_list(int index, const char* value);
  void set_username_list(int index, const char* value, size_t size);
  std::string* add_username_list();
  void add_username_list(const std::string& value);
  void add_username_list(std::string&& value);
  void add_username_list(const char* value);
  void add_username_list(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& username_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_username_list();
  private:
  const std::string& _internal_username_list(int index) const;
  std::string* _internal_add_username_list();
  public:

  // repeated .pb.ChatMsg history_msg_list = 4;
  int history_msg_list_size() const;
  private:
  int _internal_history_msg_list_size() const;
  public:
  void clear_history_msg_list();
  ::pb::ChatMsg* mutable_history_msg_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::ChatMsg >*
      mutable_history_msg_list();
  private:
  const ::pb::ChatMsg& _internal_history_msg_list(int index) const;
  ::pb::ChatMsg* _internal_add_history_msg_list();
  public:
  const ::pb::ChatMsg& history_msg_list(int index) const;
  ::pb::ChatMsg* add_history_msg_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::ChatMsg >&
      history_msg_list() const;

  // .pb.EnterRoomRsp.Retcode retcode = 1;
  void clear_retcode();
  ::pb::EnterRoomRsp_Retcode retcode() const;
  void set_retcode(::pb::EnterRoomRsp_Retcode value);
  private:
  ::pb::EnterRoomRsp_Retcode _internal_retcode() const;
  void _internal_set_retcode(::pb::EnterRoomRsp_Retcode value);
  public:

  // uint32 room_id = 2;
  void clear_room_id();
  uint32_t room_id() const;
  void set_room_id(uint32_t value);
  private:
  uint32_t _internal_room_id() const;
  void _internal_set_room_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.EnterRoomRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> username_list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::ChatMsg > history_msg_list_;
  int retcode_;
  uint32_t room_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class LeaveRoomReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:pb.LeaveRoomReq) */ {
 public:
  inline LeaveRoomReq() : LeaveRoomReq(nullptr) {}
  explicit constexpr LeaveRoomReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaveRoomReq(const LeaveRoomReq& from);
  LeaveRoomReq(LeaveRoomReq&& from) noexcept
    : LeaveRoomReq() {
    *this = ::std::move(from);
  }

  inline LeaveRoomReq& operator=(const LeaveRoomReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveRoomReq& operator=(LeaveRoomReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaveRoomReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaveRoomReq* internal_default_instance() {
    return reinterpret_cast<const LeaveRoomReq*>(
               &_LeaveRoomReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LeaveRoomReq& a, LeaveRoomReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveRoomReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveRoomReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveRoomReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaveRoomReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LeaveRoomReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LeaveRoomReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.LeaveRoomReq";
  }
  protected:
  explicit LeaveRoomReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.LeaveRoomReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class LeaveRoomRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.LeaveRoomRsp) */ {
 public:
  inline LeaveRoomRsp() : LeaveRoomRsp(nullptr) {}
  ~LeaveRoomRsp() override;
  explicit constexpr LeaveRoomRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaveRoomRsp(const LeaveRoomRsp& from);
  LeaveRoomRsp(LeaveRoomRsp&& from) noexcept
    : LeaveRoomRsp() {
    *this = ::std::move(from);
  }

  inline LeaveRoomRsp& operator=(const LeaveRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveRoomRsp& operator=(LeaveRoomRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaveRoomRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaveRoomRsp* internal_default_instance() {
    return reinterpret_cast<const LeaveRoomRsp*>(
               &_LeaveRoomRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LeaveRoomRsp& a, LeaveRoomRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveRoomRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveRoomRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveRoomRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaveRoomRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaveRoomRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LeaveRoomRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaveRoomRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.LeaveRoomRsp";
  }
  protected:
  explicit LeaveRoomRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LeaveRoomRsp_Retcode Retcode;
  static constexpr Retcode RET_SUCC =
    LeaveRoomRsp_Retcode_RET_SUCC;
  static constexpr Retcode RET_FAIL =
    LeaveRoomRsp_Retcode_RET_FAIL;
  static inline bool Retcode_IsValid(int value) {
    return LeaveRoomRsp_Retcode_IsValid(value);
  }
  static constexpr Retcode Retcode_MIN =
    LeaveRoomRsp_Retcode_Retcode_MIN;
  static constexpr Retcode Retcode_MAX =
    LeaveRoomRsp_Retcode_Retcode_MAX;
  static constexpr int Retcode_ARRAYSIZE =
    LeaveRoomRsp_Retcode_Retcode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Retcode_descriptor() {
    return LeaveRoomRsp_Retcode_descriptor();
  }
  template<typename T>
  static inline const std::string& Retcode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Retcode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Retcode_Name.");
    return LeaveRoomRsp_Retcode_Name(enum_t_value);
  }
  static inline bool Retcode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Retcode* value) {
    return LeaveRoomRsp_Retcode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRetcodeFieldNumber = 1,
  };
  // .pb.LeaveRoomRsp.Retcode retcode = 1;
  void clear_retcode();
  ::pb::LeaveRoomRsp_Retcode retcode() const;
  void set_retcode(::pb::LeaveRoomRsp_Retcode value);
  private:
  ::pb::LeaveRoomRsp_Retcode _internal_retcode() const;
  void _internal_set_retcode(::pb::LeaveRoomRsp_Retcode value);
  public:

  // @@protoc_insertion_point(class_scope:pb.LeaveRoomRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int retcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class SendMsgReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.SendMsgReq) */ {
 public:
  inline SendMsgReq() : SendMsgReq(nullptr) {}
  ~SendMsgReq() override;
  explicit constexpr SendMsgReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMsgReq(const SendMsgReq& from);
  SendMsgReq(SendMsgReq&& from) noexcept
    : SendMsgReq() {
    *this = ::std::move(from);
  }

  inline SendMsgReq& operator=(const SendMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMsgReq& operator=(SendMsgReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMsgReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMsgReq* internal_default_instance() {
    return reinterpret_cast<const SendMsgReq*>(
               &_SendMsgReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SendMsgReq& a, SendMsgReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMsgReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMsgReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMsgReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMsgReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMsgReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendMsgReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMsgReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.SendMsgReq";
  }
  protected:
  explicit SendMsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:pb.SendMsgReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class SendMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.SendMsgRsp) */ {
 public:
  inline SendMsgRsp() : SendMsgRsp(nullptr) {}
  ~SendMsgRsp() override;
  explicit constexpr SendMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMsgRsp(const SendMsgRsp& from);
  SendMsgRsp(SendMsgRsp&& from) noexcept
    : SendMsgRsp() {
    *this = ::std::move(from);
  }

  inline SendMsgRsp& operator=(const SendMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMsgRsp& operator=(SendMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SendMsgRsp*>(
               &_SendMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SendMsgRsp& a, SendMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.SendMsgRsp";
  }
  protected:
  explicit SendMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SendMsgRsp_Retcode Retcode;
  static constexpr Retcode RET_SUCC =
    SendMsgRsp_Retcode_RET_SUCC;
  static constexpr Retcode RET_FAIL =
    SendMsgRsp_Retcode_RET_FAIL;
  static constexpr Retcode RET_NOT_IN_ROOM =
    SendMsgRsp_Retcode_RET_NOT_IN_ROOM;
  static inline bool Retcode_IsValid(int value) {
    return SendMsgRsp_Retcode_IsValid(value);
  }
  static constexpr Retcode Retcode_MIN =
    SendMsgRsp_Retcode_Retcode_MIN;
  static constexpr Retcode Retcode_MAX =
    SendMsgRsp_Retcode_Retcode_MAX;
  static constexpr int Retcode_ARRAYSIZE =
    SendMsgRsp_Retcode_Retcode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Retcode_descriptor() {
    return SendMsgRsp_Retcode_descriptor();
  }
  template<typename T>
  static inline const std::string& Retcode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Retcode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Retcode_Name.");
    return SendMsgRsp_Retcode_Name(enum_t_value);
  }
  static inline bool Retcode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Retcode* value) {
    return SendMsgRsp_Retcode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRetcodeFieldNumber = 1,
  };
  // .pb.SendMsgRsp.Retcode retcode = 1;
  void clear_retcode();
  ::pb::SendMsgRsp_Retcode retcode() const;
  void set_retcode(::pb::SendMsgRsp_Retcode value);
  private:
  ::pb::SendMsgRsp_Retcode _internal_retcode() const;
  void _internal_set_retcode(::pb::SendMsgRsp_Retcode value);
  public:

  // @@protoc_insertion_point(class_scope:pb.SendMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int retcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class MsgNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.MsgNotify) */ {
 public:
  inline MsgNotify() : MsgNotify(nullptr) {}
  ~MsgNotify() override;
  explicit constexpr MsgNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgNotify(const MsgNotify& from);
  MsgNotify(MsgNotify&& from) noexcept
    : MsgNotify() {
    *this = ::std::move(from);
  }

  inline MsgNotify& operator=(const MsgNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgNotify& operator=(MsgNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgNotify* internal_default_instance() {
    return reinterpret_cast<const MsgNotify*>(
               &_MsgNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MsgNotify& a, MsgNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MsgNotify& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.MsgNotify";
  }
  protected:
  explicit MsgNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // .pb.ChatMsg msg = 1;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const ::pb::ChatMsg& msg() const;
  PROTOBUF_NODISCARD ::pb::ChatMsg* release_msg();
  ::pb::ChatMsg* mutable_msg();
  void set_allocated_msg(::pb::ChatMsg* msg);
  private:
  const ::pb::ChatMsg& _internal_msg() const;
  ::pb::ChatMsg* _internal_mutable_msg();
  public:
  void unsafe_arena_set_allocated_msg(
      ::pb::ChatMsg* msg);
  ::pb::ChatMsg* unsafe_arena_release_msg();

  // @@protoc_insertion_point(class_scope:pb.MsgNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pb::ChatMsg* msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class UserEnterNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.UserEnterNotify) */ {
 public:
  inline UserEnterNotify() : UserEnterNotify(nullptr) {}
  ~UserEnterNotify() override;
  explicit constexpr UserEnterNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserEnterNotify(const UserEnterNotify& from);
  UserEnterNotify(UserEnterNotify&& from) noexcept
    : UserEnterNotify() {
    *this = ::std::move(from);
  }

  inline UserEnterNotify& operator=(const UserEnterNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserEnterNotify& operator=(UserEnterNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserEnterNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserEnterNotify* internal_default_instance() {
    return reinterpret_cast<const UserEnterNotify*>(
               &_UserEnterNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UserEnterNotify& a, UserEnterNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(UserEnterNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserEnterNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserEnterNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserEnterNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserEnterNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserEnterNotify& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserEnterNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.UserEnterNotify";
  }
  protected:
  explicit UserEnterNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kNicknameFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string nickname = 2;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // @@protoc_insertion_point(class_scope:pb.UserEnterNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class UserLeaveNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.UserLeaveNotify) */ {
 public:
  inline UserLeaveNotify() : UserLeaveNotify(nullptr) {}
  ~UserLeaveNotify() override;
  explicit constexpr UserLeaveNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLeaveNotify(const UserLeaveNotify& from);
  UserLeaveNotify(UserLeaveNotify&& from) noexcept
    : UserLeaveNotify() {
    *this = ::std::move(from);
  }

  inline UserLeaveNotify& operator=(const UserLeaveNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLeaveNotify& operator=(UserLeaveNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLeaveNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLeaveNotify* internal_default_instance() {
    return reinterpret_cast<const UserLeaveNotify*>(
               &_UserLeaveNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UserLeaveNotify& a, UserLeaveNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLeaveNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLeaveNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLeaveNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLeaveNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLeaveNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserLeaveNotify& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLeaveNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.UserLeaveNotify";
  }
  protected:
  explicit UserLeaveNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kNicknameFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string nickname = 2;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // @@protoc_insertion_point(class_scope:pb.UserLeaveNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class ChangeNicknameReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.ChangeNicknameReq) */ {
 public:
  inline ChangeNicknameReq() : ChangeNicknameReq(nullptr) {}
  ~ChangeNicknameReq() override;
  explicit constexpr ChangeNicknameReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeNicknameReq(const ChangeNicknameReq& from);
  ChangeNicknameReq(ChangeNicknameReq&& from) noexcept
    : ChangeNicknameReq() {
    *this = ::std::move(from);
  }

  inline ChangeNicknameReq& operator=(const ChangeNicknameReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeNicknameReq& operator=(ChangeNicknameReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeNicknameReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeNicknameReq* internal_default_instance() {
    return reinterpret_cast<const ChangeNicknameReq*>(
               &_ChangeNicknameReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ChangeNicknameReq& a, ChangeNicknameReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeNicknameReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeNicknameReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeNicknameReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeNicknameReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeNicknameReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeNicknameReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeNicknameReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.ChangeNicknameReq";
  }
  protected:
  explicit ChangeNicknameReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 1,
  };
  // string nickname = 1;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // @@protoc_insertion_point(class_scope:pb.ChangeNicknameReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class ChangeNicknameRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.ChangeNicknameRsp) */ {
 public:
  inline ChangeNicknameRsp() : ChangeNicknameRsp(nullptr) {}
  ~ChangeNicknameRsp() override;
  explicit constexpr ChangeNicknameRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeNicknameRsp(const ChangeNicknameRsp& from);
  ChangeNicknameRsp(ChangeNicknameRsp&& from) noexcept
    : ChangeNicknameRsp() {
    *this = ::std::move(from);
  }

  inline ChangeNicknameRsp& operator=(const ChangeNicknameRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeNicknameRsp& operator=(ChangeNicknameRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeNicknameRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeNicknameRsp* internal_default_instance() {
    return reinterpret_cast<const ChangeNicknameRsp*>(
               &_ChangeNicknameRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ChangeNicknameRsp& a, ChangeNicknameRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeNicknameRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeNicknameRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeNicknameRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeNicknameRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeNicknameRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeNicknameRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeNicknameRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.ChangeNicknameRsp";
  }
  protected:
  explicit ChangeNicknameRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChangeNicknameRsp_Retcode Retcode;
  static constexpr Retcode RET_SUCC =
    ChangeNicknameRsp_Retcode_RET_SUCC;
  static constexpr Retcode RET_FAIL =
    ChangeNicknameRsp_Retcode_RET_FAIL;
  static constexpr Retcode RET_NICKNAME_LEN_ERROR =
    ChangeNicknameRsp_Retcode_RET_NICKNAME_LEN_ERROR;
  static inline bool Retcode_IsValid(int value) {
    return ChangeNicknameRsp_Retcode_IsValid(value);
  }
  static constexpr Retcode Retcode_MIN =
    ChangeNicknameRsp_Retcode_Retcode_MIN;
  static constexpr Retcode Retcode_MAX =
    ChangeNicknameRsp_Retcode_Retcode_MAX;
  static constexpr int Retcode_ARRAYSIZE =
    ChangeNicknameRsp_Retcode_Retcode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Retcode_descriptor() {
    return ChangeNicknameRsp_Retcode_descriptor();
  }
  template<typename T>
  static inline const std::string& Retcode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Retcode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Retcode_Name.");
    return ChangeNicknameRsp_Retcode_Name(enum_t_value);
  }
  static inline bool Retcode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Retcode* value) {
    return ChangeNicknameRsp_Retcode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRetcodeFieldNumber = 1,
  };
  // .pb.ChangeNicknameRsp.Retcode retcode = 1;
  void clear_retcode();
  ::pb::ChangeNicknameRsp_Retcode retcode() const;
  void set_retcode(::pb::ChangeNicknameRsp_Retcode value);
  private:
  ::pb::ChangeNicknameRsp_Retcode _internal_retcode() const;
  void _internal_set_retcode(::pb::ChangeNicknameRsp_Retcode value);
  public:

  // @@protoc_insertion_point(class_scope:pb.ChangeNicknameRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int retcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class NicknameChangeNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.NicknameChangeNotify) */ {
 public:
  inline NicknameChangeNotify() : NicknameChangeNotify(nullptr) {}
  ~NicknameChangeNotify() override;
  explicit constexpr NicknameChangeNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NicknameChangeNotify(const NicknameChangeNotify& from);
  NicknameChangeNotify(NicknameChangeNotify&& from) noexcept
    : NicknameChangeNotify() {
    *this = ::std::move(from);
  }

  inline NicknameChangeNotify& operator=(const NicknameChangeNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline NicknameChangeNotify& operator=(NicknameChangeNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NicknameChangeNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const NicknameChangeNotify* internal_default_instance() {
    return reinterpret_cast<const NicknameChangeNotify*>(
               &_NicknameChangeNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(NicknameChangeNotify& a, NicknameChangeNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(NicknameChangeNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NicknameChangeNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NicknameChangeNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NicknameChangeNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NicknameChangeNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NicknameChangeNotify& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NicknameChangeNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.NicknameChangeNotify";
  }
  protected:
  explicit NicknameChangeNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kNicknameFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string nickname = 2;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // @@protoc_insertion_point(class_scope:pb.NicknameChangeNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// -------------------------------------------------------------------

class PingNotify final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:pb.PingNotify) */ {
 public:
  inline PingNotify() : PingNotify(nullptr) {}
  explicit constexpr PingNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingNotify(const PingNotify& from);
  PingNotify(PingNotify&& from) noexcept
    : PingNotify() {
    *this = ::std::move(from);
  }

  inline PingNotify& operator=(const PingNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingNotify& operator=(PingNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingNotify* internal_default_instance() {
    return reinterpret_cast<const PingNotify*>(
               &_PingNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PingNotify& a, PingNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(PingNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PingNotify& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PingNotify& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PingNotify";
  }
  protected:
  explicit PingNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.PingNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cmd_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CmdData

// uint32 cmdid = 1;
inline void CmdData::clear_cmdid() {
  cmdid_ = 0u;
}
inline uint32_t CmdData::_internal_cmdid() const {
  return cmdid_;
}
inline uint32_t CmdData::cmdid() const {
  // @@protoc_insertion_point(field_get:pb.CmdData.cmdid)
  return _internal_cmdid();
}
inline void CmdData::_internal_set_cmdid(uint32_t value) {
  
  cmdid_ = value;
}
inline void CmdData::set_cmdid(uint32_t value) {
  _internal_set_cmdid(value);
  // @@protoc_insertion_point(field_set:pb.CmdData.cmdid)
}

// string cmddata = 2;
inline void CmdData::clear_cmddata() {
  cmddata_.ClearToEmpty();
}
inline const std::string& CmdData::cmddata() const {
  // @@protoc_insertion_point(field_get:pb.CmdData.cmddata)
  return _internal_cmddata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CmdData::set_cmddata(ArgT0&& arg0, ArgT... args) {
 
 cmddata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.CmdData.cmddata)
}
inline std::string* CmdData::mutable_cmddata() {
  std::string* _s = _internal_mutable_cmddata();
  // @@protoc_insertion_point(field_mutable:pb.CmdData.cmddata)
  return _s;
}
inline const std::string& CmdData::_internal_cmddata() const {
  return cmddata_.Get();
}
inline void CmdData::_internal_set_cmddata(const std::string& value) {
  
  cmddata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CmdData::_internal_mutable_cmddata() {
  
  return cmddata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CmdData::release_cmddata() {
  // @@protoc_insertion_point(field_release:pb.CmdData.cmddata)
  return cmddata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CmdData::set_allocated_cmddata(std::string* cmddata) {
  if (cmddata != nullptr) {
    
  } else {
    
  }
  cmddata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cmddata,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cmddata_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cmddata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.CmdData.cmddata)
}

// uint32 ret = 3;
inline void CmdData::clear_ret() {
  ret_ = 0u;
}
inline uint32_t CmdData::_internal_ret() const {
  return ret_;
}
inline uint32_t CmdData::ret() const {
  // @@protoc_insertion_point(field_get:pb.CmdData.ret)
  return _internal_ret();
}
inline void CmdData::_internal_set_ret(uint32_t value) {
  
  ret_ = value;
}
inline void CmdData::set_ret(uint32_t value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:pb.CmdData.ret)
}

// -------------------------------------------------------------------

// EchoCmd

// string msg = 1;
inline void EchoCmd::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& EchoCmd::msg() const {
  // @@protoc_insertion_point(field_get:pb.EchoCmd.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EchoCmd::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.EchoCmd.msg)
}
inline std::string* EchoCmd::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:pb.EchoCmd.msg)
  return _s;
}
inline const std::string& EchoCmd::_internal_msg() const {
  return msg_.Get();
}
inline void EchoCmd::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EchoCmd::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EchoCmd::release_msg() {
  // @@protoc_insertion_point(field_release:pb.EchoCmd.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EchoCmd::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.EchoCmd.msg)
}

// -------------------------------------------------------------------

// ChatMsg

// string username = 1;
inline void ChatMsg::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& ChatMsg::username() const {
  // @@protoc_insertion_point(field_get:pb.ChatMsg.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMsg::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.ChatMsg.username)
}
inline std::string* ChatMsg::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:pb.ChatMsg.username)
  return _s;
}
inline const std::string& ChatMsg::_internal_username() const {
  return username_.Get();
}
inline void ChatMsg::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChatMsg::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChatMsg::release_username() {
  // @@protoc_insertion_point(field_release:pb.ChatMsg.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChatMsg::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.ChatMsg.username)
}

// string nickname = 2;
inline void ChatMsg::clear_nickname() {
  nickname_.ClearToEmpty();
}
inline const std::string& ChatMsg::nickname() const {
  // @@protoc_insertion_point(field_get:pb.ChatMsg.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMsg::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.ChatMsg.nickname)
}
inline std::string* ChatMsg::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:pb.ChatMsg.nickname)
  return _s;
}
inline const std::string& ChatMsg::_internal_nickname() const {
  return nickname_.Get();
}
inline void ChatMsg::_internal_set_nickname(const std::string& value) {
  
  nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChatMsg::_internal_mutable_nickname() {
  
  return nickname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChatMsg::release_nickname() {
  // @@protoc_insertion_point(field_release:pb.ChatMsg.nickname)
  return nickname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChatMsg::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  nickname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.ChatMsg.nickname)
}

// uint32 time = 3;
inline void ChatMsg::clear_time() {
  time_ = 0u;
}
inline uint32_t ChatMsg::_internal_time() const {
  return time_;
}
inline uint32_t ChatMsg::time() const {
  // @@protoc_insertion_point(field_get:pb.ChatMsg.time)
  return _internal_time();
}
inline void ChatMsg::_internal_set_time(uint32_t value) {
  
  time_ = value;
}
inline void ChatMsg::set_time(uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:pb.ChatMsg.time)
}

// string content = 4;
inline void ChatMsg::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& ChatMsg::content() const {
  // @@protoc_insertion_point(field_get:pb.ChatMsg.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMsg::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.ChatMsg.content)
}
inline std::string* ChatMsg::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:pb.ChatMsg.content)
  return _s;
}
inline const std::string& ChatMsg::_internal_content() const {
  return content_.Get();
}
inline void ChatMsg::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChatMsg::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChatMsg::release_content() {
  // @@protoc_insertion_point(field_release:pb.ChatMsg.content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChatMsg::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.ChatMsg.content)
}

// -------------------------------------------------------------------

// RegisterReq

// string username = 1;
inline void RegisterReq::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& RegisterReq::username() const {
  // @@protoc_insertion_point(field_get:pb.RegisterReq.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.RegisterReq.username)
}
inline std::string* RegisterReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:pb.RegisterReq.username)
  return _s;
}
inline const std::string& RegisterReq::_internal_username() const {
  return username_.Get();
}
inline void RegisterReq::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterReq::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterReq::release_username() {
  // @@protoc_insertion_point(field_release:pb.RegisterReq.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.RegisterReq.username)
}

// string nickname = 2;
inline void RegisterReq::clear_nickname() {
  nickname_.ClearToEmpty();
}
inline const std::string& RegisterReq::nickname() const {
  // @@protoc_insertion_point(field_get:pb.RegisterReq.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterReq::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.RegisterReq.nickname)
}
inline std::string* RegisterReq::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:pb.RegisterReq.nickname)
  return _s;
}
inline const std::string& RegisterReq::_internal_nickname() const {
  return nickname_.Get();
}
inline void RegisterReq::_internal_set_nickname(const std::string& value) {
  
  nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterReq::_internal_mutable_nickname() {
  
  return nickname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterReq::release_nickname() {
  // @@protoc_insertion_point(field_release:pb.RegisterReq.nickname)
  return nickname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterReq::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  nickname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.RegisterReq.nickname)
}

// string passwd = 3;
inline void RegisterReq::clear_passwd() {
  passwd_.ClearToEmpty();
}
inline const std::string& RegisterReq::passwd() const {
  // @@protoc_insertion_point(field_get:pb.RegisterReq.passwd)
  return _internal_passwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterReq::set_passwd(ArgT0&& arg0, ArgT... args) {
 
 passwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.RegisterReq.passwd)
}
inline std::string* RegisterReq::mutable_passwd() {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:pb.RegisterReq.passwd)
  return _s;
}
inline const std::string& RegisterReq::_internal_passwd() const {
  return passwd_.Get();
}
inline void RegisterReq::_internal_set_passwd(const std::string& value) {
  
  passwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterReq::_internal_mutable_passwd() {
  
  return passwd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterReq::release_passwd() {
  // @@protoc_insertion_point(field_release:pb.RegisterReq.passwd)
  return passwd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterReq::set_allocated_passwd(std::string* passwd) {
  if (passwd != nullptr) {
    
  } else {
    
  }
  passwd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), passwd,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (passwd_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    passwd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.RegisterReq.passwd)
}

// -------------------------------------------------------------------

// RegisterRsp

// .pb.RegisterRsp.Retcode retcode = 1;
inline void RegisterRsp::clear_retcode() {
  retcode_ = 0;
}
inline ::pb::RegisterRsp_Retcode RegisterRsp::_internal_retcode() const {
  return static_cast< ::pb::RegisterRsp_Retcode >(retcode_);
}
inline ::pb::RegisterRsp_Retcode RegisterRsp::retcode() const {
  // @@protoc_insertion_point(field_get:pb.RegisterRsp.retcode)
  return _internal_retcode();
}
inline void RegisterRsp::_internal_set_retcode(::pb::RegisterRsp_Retcode value) {
  
  retcode_ = value;
}
inline void RegisterRsp::set_retcode(::pb::RegisterRsp_Retcode value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:pb.RegisterRsp.retcode)
}

// -------------------------------------------------------------------

// LoginReq

// string username = 1;
inline void LoginReq::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& LoginReq::username() const {
  // @@protoc_insertion_point(field_get:pb.LoginReq.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.LoginReq.username)
}
inline std::string* LoginReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:pb.LoginReq.username)
  return _s;
}
inline const std::string& LoginReq::_internal_username() const {
  return username_.Get();
}
inline void LoginReq::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginReq::release_username() {
  // @@protoc_insertion_point(field_release:pb.LoginReq.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.LoginReq.username)
}

// string passwd = 2;
inline void LoginReq::clear_passwd() {
  passwd_.ClearToEmpty();
}
inline const std::string& LoginReq::passwd() const {
  // @@protoc_insertion_point(field_get:pb.LoginReq.passwd)
  return _internal_passwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_passwd(ArgT0&& arg0, ArgT... args) {
 
 passwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.LoginReq.passwd)
}
inline std::string* LoginReq::mutable_passwd() {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:pb.LoginReq.passwd)
  return _s;
}
inline const std::string& LoginReq::_internal_passwd() const {
  return passwd_.Get();
}
inline void LoginReq::_internal_set_passwd(const std::string& value) {
  
  passwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_passwd() {
  
  return passwd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginReq::release_passwd() {
  // @@protoc_insertion_point(field_release:pb.LoginReq.passwd)
  return passwd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginReq::set_allocated_passwd(std::string* passwd) {
  if (passwd != nullptr) {
    
  } else {
    
  }
  passwd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), passwd,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (passwd_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    passwd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.LoginReq.passwd)
}

// -------------------------------------------------------------------

// LoginRsp

// .pb.LoginRsp.Retcode retcode = 1;
inline void LoginRsp::clear_retcode() {
  retcode_ = 0;
}
inline ::pb::LoginRsp_Retcode LoginRsp::_internal_retcode() const {
  return static_cast< ::pb::LoginRsp_Retcode >(retcode_);
}
inline ::pb::LoginRsp_Retcode LoginRsp::retcode() const {
  // @@protoc_insertion_point(field_get:pb.LoginRsp.retcode)
  return _internal_retcode();
}
inline void LoginRsp::_internal_set_retcode(::pb::LoginRsp_Retcode value) {
  
  retcode_ = value;
}
inline void LoginRsp::set_retcode(::pb::LoginRsp_Retcode value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:pb.LoginRsp.retcode)
}

// uint32 usrid = 2;
inline void LoginRsp::clear_usrid() {
  usrid_ = 0u;
}
inline uint32_t LoginRsp::_internal_usrid() const {
  return usrid_;
}
inline uint32_t LoginRsp::usrid() const {
  // @@protoc_insertion_point(field_get:pb.LoginRsp.usrid)
  return _internal_usrid();
}
inline void LoginRsp::_internal_set_usrid(uint32_t value) {
  
  usrid_ = value;
}
inline void LoginRsp::set_usrid(uint32_t value) {
  _internal_set_usrid(value);
  // @@protoc_insertion_point(field_set:pb.LoginRsp.usrid)
}

// -------------------------------------------------------------------

// EnterRoomReq

// uint32 room_id = 1;
inline void EnterRoomReq::clear_room_id() {
  room_id_ = 0u;
}
inline uint32_t EnterRoomReq::_internal_room_id() const {
  return room_id_;
}
inline uint32_t EnterRoomReq::room_id() const {
  // @@protoc_insertion_point(field_get:pb.EnterRoomReq.room_id)
  return _internal_room_id();
}
inline void EnterRoomReq::_internal_set_room_id(uint32_t value) {
  
  room_id_ = value;
}
inline void EnterRoomReq::set_room_id(uint32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:pb.EnterRoomReq.room_id)
}

// -------------------------------------------------------------------

// EnterRoomRsp

// .pb.EnterRoomRsp.Retcode retcode = 1;
inline void EnterRoomRsp::clear_retcode() {
  retcode_ = 0;
}
inline ::pb::EnterRoomRsp_Retcode EnterRoomRsp::_internal_retcode() const {
  return static_cast< ::pb::EnterRoomRsp_Retcode >(retcode_);
}
inline ::pb::EnterRoomRsp_Retcode EnterRoomRsp::retcode() const {
  // @@protoc_insertion_point(field_get:pb.EnterRoomRsp.retcode)
  return _internal_retcode();
}
inline void EnterRoomRsp::_internal_set_retcode(::pb::EnterRoomRsp_Retcode value) {
  
  retcode_ = value;
}
inline void EnterRoomRsp::set_retcode(::pb::EnterRoomRsp_Retcode value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:pb.EnterRoomRsp.retcode)
}

// uint32 room_id = 2;
inline void EnterRoomRsp::clear_room_id() {
  room_id_ = 0u;
}
inline uint32_t EnterRoomRsp::_internal_room_id() const {
  return room_id_;
}
inline uint32_t EnterRoomRsp::room_id() const {
  // @@protoc_insertion_point(field_get:pb.EnterRoomRsp.room_id)
  return _internal_room_id();
}
inline void EnterRoomRsp::_internal_set_room_id(uint32_t value) {
  
  room_id_ = value;
}
inline void EnterRoomRsp::set_room_id(uint32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:pb.EnterRoomRsp.room_id)
}

// repeated string username_list = 3;
inline int EnterRoomRsp::_internal_username_list_size() const {
  return username_list_.size();
}
inline int EnterRoomRsp::username_list_size() const {
  return _internal_username_list_size();
}
inline void EnterRoomRsp::clear_username_list() {
  username_list_.Clear();
}
inline std::string* EnterRoomRsp::add_username_list() {
  std::string* _s = _internal_add_username_list();
  // @@protoc_insertion_point(field_add_mutable:pb.EnterRoomRsp.username_list)
  return _s;
}
inline const std::string& EnterRoomRsp::_internal_username_list(int index) const {
  return username_list_.Get(index);
}
inline const std::string& EnterRoomRsp::username_list(int index) const {
  // @@protoc_insertion_point(field_get:pb.EnterRoomRsp.username_list)
  return _internal_username_list(index);
}
inline std::string* EnterRoomRsp::mutable_username_list(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EnterRoomRsp.username_list)
  return username_list_.Mutable(index);
}
inline void EnterRoomRsp::set_username_list(int index, const std::string& value) {
  username_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pb.EnterRoomRsp.username_list)
}
inline void EnterRoomRsp::set_username_list(int index, std::string&& value) {
  username_list_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pb.EnterRoomRsp.username_list)
}
inline void EnterRoomRsp::set_username_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  username_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EnterRoomRsp.username_list)
}
inline void EnterRoomRsp::set_username_list(int index, const char* value, size_t size) {
  username_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EnterRoomRsp.username_list)
}
inline std::string* EnterRoomRsp::_internal_add_username_list() {
  return username_list_.Add();
}
inline void EnterRoomRsp::add_username_list(const std::string& value) {
  username_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.EnterRoomRsp.username_list)
}
inline void EnterRoomRsp::add_username_list(std::string&& value) {
  username_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.EnterRoomRsp.username_list)
}
inline void EnterRoomRsp::add_username_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  username_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.EnterRoomRsp.username_list)
}
inline void EnterRoomRsp::add_username_list(const char* value, size_t size) {
  username_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.EnterRoomRsp.username_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EnterRoomRsp::username_list() const {
  // @@protoc_insertion_point(field_list:pb.EnterRoomRsp.username_list)
  return username_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EnterRoomRsp::mutable_username_list() {
  // @@protoc_insertion_point(field_mutable_list:pb.EnterRoomRsp.username_list)
  return &username_list_;
}

// repeated .pb.ChatMsg history_msg_list = 4;
inline int EnterRoomRsp::_internal_history_msg_list_size() const {
  return history_msg_list_.size();
}
inline int EnterRoomRsp::history_msg_list_size() const {
  return _internal_history_msg_list_size();
}
inline void EnterRoomRsp::clear_history_msg_list() {
  history_msg_list_.Clear();
}
inline ::pb::ChatMsg* EnterRoomRsp::mutable_history_msg_list(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EnterRoomRsp.history_msg_list)
  return history_msg_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::ChatMsg >*
EnterRoomRsp::mutable_history_msg_list() {
  // @@protoc_insertion_point(field_mutable_list:pb.EnterRoomRsp.history_msg_list)
  return &history_msg_list_;
}
inline const ::pb::ChatMsg& EnterRoomRsp::_internal_history_msg_list(int index) const {
  return history_msg_list_.Get(index);
}
inline const ::pb::ChatMsg& EnterRoomRsp::history_msg_list(int index) const {
  // @@protoc_insertion_point(field_get:pb.EnterRoomRsp.history_msg_list)
  return _internal_history_msg_list(index);
}
inline ::pb::ChatMsg* EnterRoomRsp::_internal_add_history_msg_list() {
  return history_msg_list_.Add();
}
inline ::pb::ChatMsg* EnterRoomRsp::add_history_msg_list() {
  ::pb::ChatMsg* _add = _internal_add_history_msg_list();
  // @@protoc_insertion_point(field_add:pb.EnterRoomRsp.history_msg_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::ChatMsg >&
EnterRoomRsp::history_msg_list() const {
  // @@protoc_insertion_point(field_list:pb.EnterRoomRsp.history_msg_list)
  return history_msg_list_;
}

// -------------------------------------------------------------------

// LeaveRoomReq

// -------------------------------------------------------------------

// LeaveRoomRsp

// .pb.LeaveRoomRsp.Retcode retcode = 1;
inline void LeaveRoomRsp::clear_retcode() {
  retcode_ = 0;
}
inline ::pb::LeaveRoomRsp_Retcode LeaveRoomRsp::_internal_retcode() const {
  return static_cast< ::pb::LeaveRoomRsp_Retcode >(retcode_);
}
inline ::pb::LeaveRoomRsp_Retcode LeaveRoomRsp::retcode() const {
  // @@protoc_insertion_point(field_get:pb.LeaveRoomRsp.retcode)
  return _internal_retcode();
}
inline void LeaveRoomRsp::_internal_set_retcode(::pb::LeaveRoomRsp_Retcode value) {
  
  retcode_ = value;
}
inline void LeaveRoomRsp::set_retcode(::pb::LeaveRoomRsp_Retcode value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:pb.LeaveRoomRsp.retcode)
}

// -------------------------------------------------------------------

// SendMsgReq

// string msg = 1;
inline void SendMsgReq::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& SendMsgReq::msg() const {
  // @@protoc_insertion_point(field_get:pb.SendMsgReq.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMsgReq::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.SendMsgReq.msg)
}
inline std::string* SendMsgReq::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:pb.SendMsgReq.msg)
  return _s;
}
inline const std::string& SendMsgReq::_internal_msg() const {
  return msg_.Get();
}
inline void SendMsgReq::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendMsgReq::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendMsgReq::release_msg() {
  // @@protoc_insertion_point(field_release:pb.SendMsgReq.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SendMsgReq::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.SendMsgReq.msg)
}

// -------------------------------------------------------------------

// SendMsgRsp

// .pb.SendMsgRsp.Retcode retcode = 1;
inline void SendMsgRsp::clear_retcode() {
  retcode_ = 0;
}
inline ::pb::SendMsgRsp_Retcode SendMsgRsp::_internal_retcode() const {
  return static_cast< ::pb::SendMsgRsp_Retcode >(retcode_);
}
inline ::pb::SendMsgRsp_Retcode SendMsgRsp::retcode() const {
  // @@protoc_insertion_point(field_get:pb.SendMsgRsp.retcode)
  return _internal_retcode();
}
inline void SendMsgRsp::_internal_set_retcode(::pb::SendMsgRsp_Retcode value) {
  
  retcode_ = value;
}
inline void SendMsgRsp::set_retcode(::pb::SendMsgRsp_Retcode value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:pb.SendMsgRsp.retcode)
}

// -------------------------------------------------------------------

// MsgNotify

// .pb.ChatMsg msg = 1;
inline bool MsgNotify::_internal_has_msg() const {
  return this != internal_default_instance() && msg_ != nullptr;
}
inline bool MsgNotify::has_msg() const {
  return _internal_has_msg();
}
inline void MsgNotify::clear_msg() {
  if (GetArenaForAllocation() == nullptr && msg_ != nullptr) {
    delete msg_;
  }
  msg_ = nullptr;
}
inline const ::pb::ChatMsg& MsgNotify::_internal_msg() const {
  const ::pb::ChatMsg* p = msg_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::ChatMsg&>(
      ::pb::_ChatMsg_default_instance_);
}
inline const ::pb::ChatMsg& MsgNotify::msg() const {
  // @@protoc_insertion_point(field_get:pb.MsgNotify.msg)
  return _internal_msg();
}
inline void MsgNotify::unsafe_arena_set_allocated_msg(
    ::pb::ChatMsg* msg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(msg_);
  }
  msg_ = msg;
  if (msg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.MsgNotify.msg)
}
inline ::pb::ChatMsg* MsgNotify::release_msg() {
  
  ::pb::ChatMsg* temp = msg_;
  msg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::ChatMsg* MsgNotify::unsafe_arena_release_msg() {
  // @@protoc_insertion_point(field_release:pb.MsgNotify.msg)
  
  ::pb::ChatMsg* temp = msg_;
  msg_ = nullptr;
  return temp;
}
inline ::pb::ChatMsg* MsgNotify::_internal_mutable_msg() {
  
  if (msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::ChatMsg>(GetArenaForAllocation());
    msg_ = p;
  }
  return msg_;
}
inline ::pb::ChatMsg* MsgNotify::mutable_msg() {
  ::pb::ChatMsg* _msg = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:pb.MsgNotify.msg)
  return _msg;
}
inline void MsgNotify::set_allocated_msg(::pb::ChatMsg* msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete msg_;
  }
  if (msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::ChatMsg>::GetOwningArena(msg);
    if (message_arena != submessage_arena) {
      msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    
  } else {
    
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:pb.MsgNotify.msg)
}

// -------------------------------------------------------------------

// UserEnterNotify

// string username = 1;
inline void UserEnterNotify::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& UserEnterNotify::username() const {
  // @@protoc_insertion_point(field_get:pb.UserEnterNotify.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserEnterNotify::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.UserEnterNotify.username)
}
inline std::string* UserEnterNotify::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:pb.UserEnterNotify.username)
  return _s;
}
inline const std::string& UserEnterNotify::_internal_username() const {
  return username_.Get();
}
inline void UserEnterNotify::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserEnterNotify::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserEnterNotify::release_username() {
  // @@protoc_insertion_point(field_release:pb.UserEnterNotify.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserEnterNotify::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.UserEnterNotify.username)
}

// string nickname = 2;
inline void UserEnterNotify::clear_nickname() {
  nickname_.ClearToEmpty();
}
inline const std::string& UserEnterNotify::nickname() const {
  // @@protoc_insertion_point(field_get:pb.UserEnterNotify.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserEnterNotify::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.UserEnterNotify.nickname)
}
inline std::string* UserEnterNotify::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:pb.UserEnterNotify.nickname)
  return _s;
}
inline const std::string& UserEnterNotify::_internal_nickname() const {
  return nickname_.Get();
}
inline void UserEnterNotify::_internal_set_nickname(const std::string& value) {
  
  nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserEnterNotify::_internal_mutable_nickname() {
  
  return nickname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserEnterNotify::release_nickname() {
  // @@protoc_insertion_point(field_release:pb.UserEnterNotify.nickname)
  return nickname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserEnterNotify::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  nickname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.UserEnterNotify.nickname)
}

// -------------------------------------------------------------------

// UserLeaveNotify

// string username = 1;
inline void UserLeaveNotify::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& UserLeaveNotify::username() const {
  // @@protoc_insertion_point(field_get:pb.UserLeaveNotify.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLeaveNotify::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.UserLeaveNotify.username)
}
inline std::string* UserLeaveNotify::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:pb.UserLeaveNotify.username)
  return _s;
}
inline const std::string& UserLeaveNotify::_internal_username() const {
  return username_.Get();
}
inline void UserLeaveNotify::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserLeaveNotify::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserLeaveNotify::release_username() {
  // @@protoc_insertion_point(field_release:pb.UserLeaveNotify.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserLeaveNotify::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.UserLeaveNotify.username)
}

// string nickname = 2;
inline void UserLeaveNotify::clear_nickname() {
  nickname_.ClearToEmpty();
}
inline const std::string& UserLeaveNotify::nickname() const {
  // @@protoc_insertion_point(field_get:pb.UserLeaveNotify.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLeaveNotify::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.UserLeaveNotify.nickname)
}
inline std::string* UserLeaveNotify::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:pb.UserLeaveNotify.nickname)
  return _s;
}
inline const std::string& UserLeaveNotify::_internal_nickname() const {
  return nickname_.Get();
}
inline void UserLeaveNotify::_internal_set_nickname(const std::string& value) {
  
  nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserLeaveNotify::_internal_mutable_nickname() {
  
  return nickname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserLeaveNotify::release_nickname() {
  // @@protoc_insertion_point(field_release:pb.UserLeaveNotify.nickname)
  return nickname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserLeaveNotify::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  nickname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.UserLeaveNotify.nickname)
}

// -------------------------------------------------------------------

// ChangeNicknameReq

// string nickname = 1;
inline void ChangeNicknameReq::clear_nickname() {
  nickname_.ClearToEmpty();
}
inline const std::string& ChangeNicknameReq::nickname() const {
  // @@protoc_insertion_point(field_get:pb.ChangeNicknameReq.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeNicknameReq::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.ChangeNicknameReq.nickname)
}
inline std::string* ChangeNicknameReq::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:pb.ChangeNicknameReq.nickname)
  return _s;
}
inline const std::string& ChangeNicknameReq::_internal_nickname() const {
  return nickname_.Get();
}
inline void ChangeNicknameReq::_internal_set_nickname(const std::string& value) {
  
  nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeNicknameReq::_internal_mutable_nickname() {
  
  return nickname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeNicknameReq::release_nickname() {
  // @@protoc_insertion_point(field_release:pb.ChangeNicknameReq.nickname)
  return nickname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeNicknameReq::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  nickname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.ChangeNicknameReq.nickname)
}

// -------------------------------------------------------------------

// ChangeNicknameRsp

// .pb.ChangeNicknameRsp.Retcode retcode = 1;
inline void ChangeNicknameRsp::clear_retcode() {
  retcode_ = 0;
}
inline ::pb::ChangeNicknameRsp_Retcode ChangeNicknameRsp::_internal_retcode() const {
  return static_cast< ::pb::ChangeNicknameRsp_Retcode >(retcode_);
}
inline ::pb::ChangeNicknameRsp_Retcode ChangeNicknameRsp::retcode() const {
  // @@protoc_insertion_point(field_get:pb.ChangeNicknameRsp.retcode)
  return _internal_retcode();
}
inline void ChangeNicknameRsp::_internal_set_retcode(::pb::ChangeNicknameRsp_Retcode value) {
  
  retcode_ = value;
}
inline void ChangeNicknameRsp::set_retcode(::pb::ChangeNicknameRsp_Retcode value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:pb.ChangeNicknameRsp.retcode)
}

// -------------------------------------------------------------------

// NicknameChangeNotify

// string username = 1;
inline void NicknameChangeNotify::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& NicknameChangeNotify::username() const {
  // @@protoc_insertion_point(field_get:pb.NicknameChangeNotify.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NicknameChangeNotify::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.NicknameChangeNotify.username)
}
inline std::string* NicknameChangeNotify::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:pb.NicknameChangeNotify.username)
  return _s;
}
inline const std::string& NicknameChangeNotify::_internal_username() const {
  return username_.Get();
}
inline void NicknameChangeNotify::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NicknameChangeNotify::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NicknameChangeNotify::release_username() {
  // @@protoc_insertion_point(field_release:pb.NicknameChangeNotify.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NicknameChangeNotify::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.NicknameChangeNotify.username)
}

// string nickname = 2;
inline void NicknameChangeNotify::clear_nickname() {
  nickname_.ClearToEmpty();
}
inline const std::string& NicknameChangeNotify::nickname() const {
  // @@protoc_insertion_point(field_get:pb.NicknameChangeNotify.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NicknameChangeNotify::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.NicknameChangeNotify.nickname)
}
inline std::string* NicknameChangeNotify::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:pb.NicknameChangeNotify.nickname)
  return _s;
}
inline const std::string& NicknameChangeNotify::_internal_nickname() const {
  return nickname_.Get();
}
inline void NicknameChangeNotify::_internal_set_nickname(const std::string& value) {
  
  nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NicknameChangeNotify::_internal_mutable_nickname() {
  
  return nickname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NicknameChangeNotify::release_nickname() {
  // @@protoc_insertion_point(field_release:pb.NicknameChangeNotify.nickname)
  return nickname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NicknameChangeNotify::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  nickname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.NicknameChangeNotify.nickname)
}

// -------------------------------------------------------------------

// PingNotify

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pb::RegisterRsp_Retcode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::RegisterRsp_Retcode>() {
  return ::pb::RegisterRsp_Retcode_descriptor();
}
template <> struct is_proto_enum< ::pb::LoginRsp_Retcode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::LoginRsp_Retcode>() {
  return ::pb::LoginRsp_Retcode_descriptor();
}
template <> struct is_proto_enum< ::pb::EnterRoomRsp_Retcode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EnterRoomRsp_Retcode>() {
  return ::pb::EnterRoomRsp_Retcode_descriptor();
}
template <> struct is_proto_enum< ::pb::LeaveRoomRsp_Retcode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::LeaveRoomRsp_Retcode>() {
  return ::pb::LeaveRoomRsp_Retcode_descriptor();
}
template <> struct is_proto_enum< ::pb::SendMsgRsp_Retcode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::SendMsgRsp_Retcode>() {
  return ::pb::SendMsgRsp_Retcode_descriptor();
}
template <> struct is_proto_enum< ::pb::ChangeNicknameRsp_Retcode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ChangeNicknameRsp_Retcode>() {
  return ::pb::ChangeNicknameRsp_Retcode_descriptor();
}
template <> struct is_proto_enum< ::pb::ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ErrorCode>() {
  return ::pb::ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::pb::CmdId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::CmdId>() {
  return ::pb::CmdId_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_cmd_2eproto
